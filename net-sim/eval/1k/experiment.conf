NAME=1k

# animated scenarios must have the link to the mobility model to a file in /shared
# autostart should be enabled for the movement
# node mapping must fit the scenario
# movements can be generated using bonnmotion
SCENARIO=1k.xml

# optional core automator recording, will be played in a loop
AUTOMATOR=1k.pos


N1_EMAIL='n1@monntpy.tu-darmstadt.de'
N2_EMAIL='n2@monntpy.tu-darmstadt.de'
N3_EMAIL='n3@monntpy.tu-darmstadt.de'
SENDER_INTERVAL=0
NUM_ARTICLES=1000

GUI=0

MONITOR_PIDSTAT=1
# monitor specific process name (default, all on node -> no graph plotting!)
# this is a bit shaky, but to monitor moNNT.py, which runs in its own environment,
# we have to monitor the process that ends in "python"
MONITOR_PIDSTAT_PARAMS="python$"

MONITOR_NET=1
# interface to monitor (default: all interfaces up)
MONITOR_NET_PARAMS="eth0"

MONITOR_XY=0
# Delay in seconds between recordings
# MONITOR_XY_PARAMS="5"

MONITOR_CONTACTS=0
# Delay in seconds between recordings
# MONITOR_CONTACTS_PARAMS="5"

# commands to execute at beginning of simulation
# START_EXEC=('echo THIS IS IMPORTANT $(hostname)')

# commands to daemonize at beginning of simulation, e.g., dtnd
# START_DAEMONIZED=('dtnd --cla mtcp --nodeid $(hostname) --interval 1s --janitor 1s')

# usually commands started at the beginning of the simulation are put here for shutdown
SHUTDOWN_PROCS="dtnd python"

# let simulation warm up for a period of time if needed
WARMUP=0

# run simulation for this long
# without RUNTIME simulation will run until a shutdown.txt is found in the shared volume
RUNTIME=120

# COLLECT_EVERYTHING=1

# Called right after initializing the simulation, prior to any monitoring or START_EXEC/START_DAEMONIZED
pre() {
    echo "pre hook - results in $1"
    cp /app/assets/config.py /app/moNNT.py/backend/dtn7sqlite/config.py
    cp /app/assets/logging_conf.ini /app/moNNT.py/

    cexec n1 "nohup dtnd --cla mtcp --nodeid n1 --interval 2s --janitor 4s > nohup.dtnd_n1.log 2>&1 & sleep 1"
    cexec n2 "nohup dtnd --cla mtcp --nodeid n2 --interval 2s --janitor 4s --debug > nohup.dtnd_n2.log 2>&1 & sleep 1"
    cexec n3 "nohup dtnd --cla mtcp --nodeid n3 --interval 2s --janitor 4s > nohup.dtnd_n3.log 2>&1 & sleep 1"

    cexec n1 "export SENDER_EMAIL=$N1_EMAIL && nohup start-monntpy.sh > nohup.monntpy_n1.log 2>&1 & sleep 2"
    cexec n2 "export SENDER_EMAIL=$N2_EMAIL && nohup start-monntpy.sh > nohup.monntpy_n2.log 2>&1 & sleep 0.1"
    cexec n3 "export SENDER_EMAIL=$N3_EMAIL && nohup start-monntpy.sh > nohup.monntpy_n3.log 2>&1 & sleep 2"

    echo "Starting client mass sender threads on N1 and N3"
    cexec n1 "nohup nntp_sender.py 127.0.0.1 $N1_EMAIL $SENDER_INTERVAL $NUM_ARTICLES > nntp_sender_n1.log 2>&1 & sleep 0.1"
    cexec n3 "nntp_sender.py 127.0.0.1 $N3_EMAIL $SENDER_INTERVAL $NUM_ARTICLES > nntp_sender_n3.log 2>&1"
    echo "Mass sender threads done."
}

# Called right after starting monitoring and/or START_EXEC/START_DAEMONIZED
start() {
    echo "start hook - results in $1"

    # nohup messagedeliveryreport 5 conf conf > $1/messagedeliveryreport.log &
    # nohup messagedeliveryreport_dtnd 1 > $1/messagedeliveryreport_dtnd.log &


}

# Called after simulation time is over but prior to collecting logs
post() {
    echo "post hook - results in $1"
}

# Called after logs have been collected from all nodes
analyze() {
    echo "post hook - results in $1"

    # messagestatsreport $1 > $1/messagestatsreport.txt

    # SENT=$(cat $1/n*/nohup.mqtt_sender.log | grep " : " | wc -l)
    # DELIVERED=$(cat $1/receiver/nohup.dtnmqtt.*.log | grep "SUB RECV" | cut -d '/' -f3- | sort -u | wc -l)
    # RECEIVED=$(cat $1/receiver/nohup.mosquitto_sub.log | wc -l)

    # calculate throughput
    # RATE=$(echo "scale=2; $RECEIVED / $SENT" | bc)
    # RATE2=$(echo "scale=2; $DELIVERED / $SENT" | bc)
    # echo "EXPERIMENT RESULT: tx: $SENT, rx: $RECEIVED, dx: $DELIVERED | rate: $RATE | delivered: $RATE2"
}