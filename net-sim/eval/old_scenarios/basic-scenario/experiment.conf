NAME=three-tier

# animated scenarios must have the link to the mobility model to a file in /shared
# autostart should be enabled for the movement
# node mapping must fit the scenario
# movements can be generated using bonnmotion
SCENARIO=basic-scenario.xml

# optional core automator recording, will be played in a loop
#AUTOMATOR=three_nodes.pos

N1_EMAIL='alice@tu-darmstadt.de'
N2_EMAIL='bob@gmail.com'
N3_EMAIL='clara@posteo.de'
N4_EMAIL='daniel@yahoo.com'

SENDER_INTERVAL=1

GUI=0

MONITOR_PIDSTAT=1
# monitor specific process name (default, all on node -> no graph plotting!)
# this is a bit shaky, but to monitor moNNT.py, which runs in its own environment,
# we have to monitor the process that ends in "python"
MONITOR_PIDSTAT_PARAMS="python$"

MONITOR_NET=1
# interface to monitor (default: all interfaces up)
MONITOR_NET_PARAMS="eth0"

MONITOR_XY=0
# Delay in seconds between recordings
#MONITOR_XY_PARAMS="5"

MONITOR_CONTACTS=0
# Delay in seconds between recordings
#MONITOR_CONTACTS_PARAMS="1"

# commands to execute at beginning of simulation
#START_EXEC=("echo started > started.log" "echo second > second.log")

# commands to daemonize at beginning of simulation, e.g., dtnd
START_DAEMONIZED=('dtnd --cla mtcp --nodeid $(hostname)')

# usually commands started at the beginning of the simulation are put here for shutdown
SHUTDOWN_PROCS="nntp_sender.py start-monntpy.sh python dtnd messagedeliveryreport messagedeliveryreport_dtnd"

# let simulation warm up for a period of time if needed
WARMUP=2

# run simulation for this long
# without RUNTIME simulation will run until a shutdown.txt is found in the shared volume
RUNTIME=30

#COLLECT_EVERYTHING=1

# Called right after initializing the simulation, prior to any monitoring or START_EXEC/START_DAEMONIZED
pre() {
    echo "pre hook - results in $1"

    # configuration file is the same for all nodes. Customization happens through environment variables
    # in the call to start-monntpy.sh in start()
    cp /app/modified/config.py /app/moNNT.py/backend/dtn7sqlite/config.py
    # Copy fresh DBs into all nodes
    for d in /tmp/pycore.*/n*; do
        cp /app/modified/db.sqlite3 "$d.conf/";
    done;
    cexec n1 "export SENDER_EMAIL=$N1_EMAIL && nohup start-monntpy.sh > nohup.monntpy.log 2>&1 & sleep 0.1"
    cexec n2 "export SENDER_EMAIL=$N2_EMAIL && nohup start-monntpy.sh > nohup.monntpy.log 2>&1 & sleep 0.1"
    cexec n3 "export SENDER_EMAIL=$N3_EMAIL && nohup start-monntpy.sh > nohup.monntpy.log 2>&1 & sleep 0.1"
    cexec n4 "export SENDER_EMAIL=$N4_EMAIL && nohup start-monntpy.sh > nohup.monntpy.log 2>&1 & sleep 0.1"
}

# Called right after starting monitoring and/or START_EXEC/START_DAEMONIZED
start() {
    nohup messagedeliveryreport 10 node.conf node.conf > $1/messagedeliveryreport.log &
    nohup messagedeliveryreport_dtnd 1 > $1/messagedeliveryreport_dtnd.log &

    cexec n4 "nohup nntp_sender.py 127.0.0.1 $N4_EMAIL $SENDER_INTERVAL > nohup.nntp_sender.log 2>&1 & sleep 0.1"
}

# Called after simulation time is over but prior to collecting logs
post() {
    echo "post hook - results in $1"
}

# Called after logs have been collected from all nodes
analyze() {
    echo "analyze hook - results in $1"
    messagestatsreport $1 > $1/messagestatsreport.txt
    
    # collect number of sent messages and received messages
    SENT=$(cat $1/n4/nohup.nntp_sender.log | grep 'Sending article' | wc -l)
    RECEIVED=$(cat $1/n1/nohup.monntpy.log | grep 'Creating article entry' | wc -l)
    
    RATE=$(echo "scale=2; $RECEIVED / $SENT" | bc)
    echo "EXPERIMENT RESULT: tx: $SENT, rx: $RECEIVED | rate: $RATE"
}